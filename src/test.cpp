#include "../headers/allHeaders.h"

#include <filesystem>
#include <cmath>

#include <chrono>


// bool Test::FxnOddEven(long vertexId)
// {
//     if(vertexId % 2 == 1)
//         return true;
//     return false;
// }

// bool Test::FxnOddEven_(long v1Id, long v2Id)
// {
//     if((v1Id + v2Id) % 2 == 1)
//         return true;
//     return false;
// }

bool OddEven(long vertexId)
{
    if(vertexId % 2 == 1)      //!! Should be odd, then only true
        return true;
    return false;
//    return true;
}

bool OddEven_(long v1Id, long v2Id)
{
    if((v1Id + v2Id) % 2 == 1) //!Sum should be odd, then only true
        return true;
    return false;
//    return true;
}

Test::Test(int threads, std::string logPath, const std::fstream & stream) : p_currFileStream(stream)
{
    p_threadsCount = threads;
    p_logFilePath = logPath;
}


std::vector<long> Test::GenerateRandomIntegers(long minInteger, 
                                               long maxInteger, 
                                               long totalNumbers)
{
    srand(100);  //Changed from rand(). srand() seeds rand for you.

    std::vector<long> retV;
    for(long i = 0; i < totalNumbers; ++i)
        retV.emplace_back(rand() % maxInteger + minInteger);

    return retV;
}    

void Test::TestVertexSubset(Graph &g,
                      VertexSubset &vs,
                      long nodesCountInSubset,
                      std::string &logFile)
{
    std::fstream fileStream(logFile, std::ios::app);

    //fileStream << "Beginning the test vertex subset function" << std::endl;

    //!Set this vertex subset
    std::vector<long> subsetIds = GenerateRandomIntegers(0,
                                               g.getNumberVertices(),
                                               nodesCountInSubset);

    std::sort(subsetIds.begin(), subsetIds.end());
    subsetIds.erase(std::unique(subsetIds.begin(), subsetIds.end()), subsetIds.end());

    vs.setVertexSubset(subsetIds);
    fileStream << "Number of vertices: "<< vs.getVertexSubsetLength() << " | Outdegree: " << vs.getVertexSubsetOutDegree(g) << std::endl;
    //fileStream << "Below is the input vector subset:" << std::endl;
    vs.LogIntoFile(fileStream);

    //VertexSubset o = Interface::VertexMap(vs, &OddEven);
    VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);

    std::cout << "Dense Done" << std::endl;
    VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
    std::cout << "Sparse Done" << std::endl;

    //!Error between edge map sparse and edge map dense should be zero
    bool thereIsAnError = false;
    if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
    {
        //!If length is different, flag this error
        fileStream << "Different sizes generated by edgeMapSparse and edgeMapDense" << std::endl;
        thereIsAnError = true;
    }
    else
    {
        for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
        {
            long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
            if(error != 0)
            {
                fileStream << "Different subsets generated by edgeMapSparse and edgeMapDense" << std::endl;
                thereIsAnError = true;
                break;
            }   
        }
    }
    fileStream << " " << std::endl;
    fileStream << " " << std::endl;    
//     //Testing: VertexMap
//     //std::cout << "Vertex Map Function output: " << std::endl;
//     VertexSubset o = Interface::VertexMap(vs, &OddEven);
//     //o.printVertexSubset();
//     //std::cout << "After calling Vertex Map Function" << std::endl;

//     //Testing EdgeMapSparse
// //    std::cout << "Before calling Edge Map Sparse Function" << std::endl;
//     VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
// //    o1.printVertexSubset();
// //    std::cout << "After calling Edge Map Sparse Function" << std::endl;

//     //Testing EdgeMapDense
// //    std::cout << "Before calling Edge Map Dense Function" << std::endl;
//     VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);
// //    o2.printVertexSubset();
// //    std::cout << "After calling Edge Map Dense Function" << std::endl;

//     //!Error between edge map sparse and edge map dense should be zero
//     bool thereIsAnError = false;
//     if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
//     {
//         //!If length is different, flag this error
//         thereIsAnError = true;
//     }
//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
//     {
//         long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
//         if(error != 0)
//         {
//             thereIsAnError = true;
//             break;
//         }   
//     }

//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     std::cout << std::endl;
//     std::cout << std::endl;
}

void Test::DoTestingOnThisGraph(Graph &currGraph, std::string &logFile)
{
    long verticesCount = currGraph.getNumberVertices();

    std::vector<long> individualSubsetSizes;
    for(int i = 1; i <= 10; ++i)
    {
        long subSetSize = std::ceil(verticesCount * i * 10./100);
        individualSubsetSizes.push_back(subSetSize);
    }
    individualSubsetSizes.erase(std::unique(individualSubsetSizes.begin(), individualSubsetSizes.end()), individualSubsetSizes.end());

    //!Select 30 percent of nodes at random
    std::vector<long> randomSourcesIndeices = GenerateRandomIntegers(0, verticesCount - 1,std::floor(verticesCount * 3/10));

    for(auto currSource: randomSourcesIndeices)
    {
        p_currFileStream << "Current Source Index" << currSource << std::endl; 

        //!Testing BFS
        p_currFileStream << "Testing BFS" << std::endl; 
        TestBFS(currGraph,i);

        p_currFileStream << std::endl; 
        p_currFileStream << std::endl;        
        p_currFileStream << "Testing BF" << std::endl; 
        //!Testing BF
        TestBF(currGraph,i);


        p_currFileStream << std::endl; 
        p_currFileStream << std::endl;
        p_currFileStream << std::endl; 
        p_currFileStream << std::endl;
    }

    //!When done for all sources and other shit
    p_currFileStream << std::endl; 
    p_currFileStream << std::endl;
    p_currFileStream << "Final Log --> Summary" << std::endl;    
    p_currFileStream << "BFS" << std::endl;    
    for(int j = 0; j < p_BF_parTimes.size(); ++j)
    {
        p_currFileStream << "Source Vertex:" << currGraph.getVertexPointer(p_sourceVertices[j])->getDataValue() << " | Success: " << p_comparisonSuccess[j] << " | Seq Time: " << p_seqTimesBFS[j] << " | Parallel Time: " << p_parallelTimesBFS[j] << " | SpeedUp: " << p_speedUpBFS[j] << " | Max Layers at dist: " << p_maxLayersCount[j] << std::endl        
    }

    p_currFileStream << "BF" << std::endl;    
    for(int j = 0; j < p_BF_parTimes.size(); ++j)
    {
        p_currFileStream << "Source Vertex:" << currGraph.getVertexPointer(p_BF_sourceVertices[j])->getDataValue() << " | Success: " << p_BF_comparisonSuccess[j] << " | Seq Time: " << p_BF_seqTimes[j] << " | Parallel Time: " << p_BF_parTimes[j] << " | SpeedUp: " << p_BF_speedUp[j] << std::endl        
    }



    // std::cout << "Running Seq" << std::endl;
    // bfs_s(currGraph,0);
    // std::cout << "Running Parallel" << std::endl;
    // bfs(currGraph,0);
//     for(int i = 0; i < 1; ++i)
//     {
// //        std::cout << "New Call" << " Root: " << i << std::endl;
//         TestBF(currGraph,i);
// //        std::cout << "   " << std::endl;        
//     }


    // for(auto &subSetSize : individualSubsetSizes)
    // {
    //     VertexSubset vs;

    //     std::fstream fileStream(logFile, std::ios::app);
    //     //fileStream << "Beginning of the testing on this graph function" << std::endl;
    //     fileStream << " " << std::endl;
    //     //fileStream << "Percentage of nodes selected for subset: "  << i * 10 << "%" <<std::endl;

    //     TestVertexSubset(currGraph,
    //                      vs,
    //                      subSetSize,
    //                      logFile);

    //     //fileStream << "Ending of the testing on this graph function" << std::endl;
    //     fileStream << " " << std::endl;
    //     //break;
    // }
}


bool Test::CompareLayers(std::deque<long> &layers, std::deque<long> &layers_s)
{
    for(long i = 0; i < layers.size(); i++)
    {
        if(layers[i] != layers_s[i])
        {
            p_currFileStream << "Layers MisMatch at vertex" <<i  << " |Data val: " << currGraph.getVertexPointer(i)->getDataValue <<std::endl;
            //std::cout<<"Layers MisMatch at vertex"<<i<<std::endl;
            return false;
        }           
    }
    //std::cout<<"Layers Match!"<<std::endl;
    //p_currFileStream << "Layers Matched!" <<std::endl;
    return true;
}

void Test::TestBFS(Graph& currGraph, long root)
{
    extern std::deque<long> parents;
    extern std::deque<long> layers;
    extern std::deque<long> parents_s;  //!Sequential
    extern std::deque<long> layers_s;   //!Sequential

    auto startS = std::chrono::high_resolution_clock::now();
    bfs_s(currGraph, root);
    
    //std::cout<<"Done Sequential\n";

    auto startP = std::chrono::high_resolution_clock::now();
    bfs(currGraph, root);
    auto end = std::chrono::high_resolution_clock::now();


    auto seqT = std::chrono::duration<double>(startP - startS);
    auto parallelT = std::chrono::duration<double>(end - startP);

    //std::cout << "Seq Time: " << seqT.count() << " Parallel Time: " << parallelT.count() << std::endl;
    //p_currFileStream << "Seq Time: " << seqT.count() << " Parallel Time: " << parallelT.count() << std::endl;

    auto maxElemIter = std::max_element(layers.begin(), layers.end());

    p_sourceVertices.push_back(root);
    p_seqTimesBFS.push_back(seqT.count());
    p_parallelTimesBFS.push_back(parallelT.count());
    p_speedUpBFS.push_back(seqT.count()/parallelT.count());
    p_maxLayersCount(*maxElemIter)

    bool compSuccess = CompareLayers(layers, layers_s);
    if(compSuccess)
    {
        p_currFileStream << "Correctly ran for source vertex: " << root <<" |Data val: " << currGraph.getVertexPointer(root)->getDataValue <<std::endl;
    }
    p_comparisonSuccess.push_back(compSuccess);
}


bool Test::CompareSPs(std::deque<double> &SP, std::deque<double> &SP_s)
{
    for(long i = 0; i < SP.size(); i++)
    {
        if(SP[i] != SP_s[i])
        {
            //std::cout<<"SP MisMatch at vertex "<<i<<std::endl; 
            p_currFileStream <<"BF -> SP MisMatch at vertex: "<<i  << " |Data val: " << currGraph.getVertexPointer(i)->getDataValue <<std::endl; 
            return false;
        }
           
    }
    //std::cout<<"SPs Match!"<<std::endl;
    return true;
}
void Test::TestBF(Graph& currGraph, long root)
{
    extern std::deque<double> SP;
    extern std::deque<long> Visited;
    extern std::deque<double>SP_s;
    extern std::deque<long> Visited_s;

    //std::cout<<"It all starts here\n";
    
    auto startS = std::chrono::high_resolution_clock::now();

    bellmanFord(currGraph, root);   //!Call this seq with number of threds are 1
    //bellmanFord_s(currGraph, root);
    //std::cout<<"Done Sequential\n";

    auto startP = std::chrono::high_resolution_clock::now();


    bellmanFord(currGraph, root);   //!Parallel with num of threads more than 1
    auto end = std::chrono::high_resolution_clock::now();
    auto seqT = std::chrono::duration<double>(startP - startS);
    auto parallelT = std::chrono::duration<double>(end - startP);

    //std::cout << "Seq Time: " << seqT.count() << " Parallel Time: " << parallelT.count() << std::endl;
    bool compSuccess = CompareSPs(SP, SP_s);


    p_BF_sourceVertices.push_back(root);
    p_BF_seqTimes.push_back(seqT.count());
    p_BF_parTimes.push_back(parallelT.count());
    p_BF_speedUp.push_back(seqT.count()/parallelT.count());

    if(compSuccess)
    {
        p_currFileStream << "BF --> Correctly ran for source vertex: " << root << " |Data val: " << currGraph.getVertexPointer(root)->getDataValue <<std::endl;
    }
    p_BF_comparisonSuccess.push_back(compSuccess);
}